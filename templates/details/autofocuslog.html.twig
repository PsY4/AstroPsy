<div class="card-body">
{# --- V-Curve chart --- #}
<h6 class="mb-2 mt-3"><i class="fa fa-fw fa-chart-line me-1"></i>{{ 'autofocus.section_vcurve'|trans }}</h6>
<div id="af-graph-container" style="position:relative; height:350px">
    <canvas id="afVcurveChart"></canvas>
</div>

{# --- Measure points table --- #}
{% if af.measurePoints|length > 0 %}
<h6 class="mb-2 mt-4"><i class="fa fa-fw fa-list me-1"></i>{{ 'autofocus.section_details'|trans }}</h6>
<div class="table-responsive mb-3">
    <table class="table table-sm table-striped mb-0" style="font-size: 12px">
        <thead>
            <tr class="table-dark">
                <th>#</th>
                <th class="text-end">{{ 'autofocus.col_position'|trans }}</th>
                <th class="text-end">{{ 'autofocus.col_hfr'|trans }}</th>
                <th class="text-end">Error</th>
            </tr>
        </thead>
        <tbody>
            {% for pt in af.measurePoints %}
            <tr>
                <td class="text-muted">{{ loop.index }}</td>
                <td class="text-end">{{ pt.position ? pt.position|number_format(0) : '—' }}</td>
                <td class="text-end">{{ pt.value ? pt.value|number_format(3) : '—' }}</td>
                <td class="text-end">{{ pt.error ? pt.error|number_format(3) : '—' }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>
{% endif %}

{# --- Annotated images --- #}
<h6 class="mb-2 mt-4"><i class="fa fa-fw fa-images me-1"></i>{{ 'autofocus.section_images'|trans }}</h6>
<div id="af-images-grid" class="row g-2"></div>
</div>

{# --- Lightbox modal --- #}
<div class="modal fade" id="afLightboxModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-xl">
        <div class="modal-content bg-dark">
            <div class="modal-body p-0 text-center">
                <img id="afLightboxImg" src="" class="img-fluid" style="max-height:90vh">
            </div>
        </div>
    </div>
</div>

<script>
(function() {
    // V-Curve chart
    var points = {{ af.measurePoints|default([])|json_encode|raw }};
    var calcPos = {{ af.calculatedPosition|default('null') }};
    var calcHfr = {{ af.calculatedHfr|default('null') }};
    var fittingsData = {{ af.fittings|default('null')|json_encode|raw }};

    if (points && points.length > 0) {
        var ctx = document.getElementById('afVcurveChart').getContext('2d');

        var scatterData = points.map(function(pt) {
            return { x: pt.position, y: pt.value };
        });

        var errorBars = points.map(function(pt) {
            return {
                x: pt.position,
                yMin: Math.max(0, (pt.value || 0) - (pt.error || 0)),
                yMax: (pt.value || 0) + (pt.error || 0)
            };
        });

        var datasets = [{
            label: 'HFR',
            data: scatterData,
            backgroundColor: 'rgba(54, 162, 235, 0.8)',
            borderColor: 'rgba(54, 162, 235, 1)',
            pointRadius: 5,
            pointHoverRadius: 7,
            showLine: false,
            order: 1
        }];

        // Hyperbolic fitting curve
        if (fittingsData && points.length > 1) {
            var positions = points.map(function(p) { return p.position; });
            var minPos = Math.min.apply(null, positions);
            var maxPos = Math.max.apply(null, positions);
            var range = maxPos - minPos;
            var pad = range * 0.05;
            var curvePoints = [];

            // Parse NINA/Hocus Focus hyperbolic formula:
            // y = min(max(0, (C - x) / T), 1) * A/B1 * √((x - C)² + B1²)
            //   + (1 - min(max(0, (C - x) / T), 1)) * A/B2 * √((x - C)² + B2²) + offset
            function parseHyperbolic(str) {
                if (!str || typeof str !== 'string') return null;
                // Extract C from "(C - x)"
                var mC = str.match(/\(([-\d.]+)\s*-\s*x\)/);
                if (!mC) return null;
                var c = parseFloat(mC[1]);
                // Extract transition width T from "/ T), 1)"
                var mT = str.match(/\/\s*([\d.]+)\),\s*1\)/);
                var t = mT ? parseFloat(mT[1]) : 25;
                // Extract A/B1 and A/B2 ratios
                var ratios = [];
                var re = /([-\d.]+)\/([-\d.]+)\s*\*/g;
                var match;
                while ((match = re.exec(str)) !== null) {
                    ratios.push({ a: parseFloat(match[1]), b: parseFloat(match[2]) });
                }
                if (ratios.length < 2) return null;
                // Extract offset from "+ offset" at end
                var mOff = str.match(/\+\s*([-\d.]+)\s*$/);
                var offset = mOff ? parseFloat(mOff[1]) : 0;
                return { c: c, t: t, a: ratios[0].a, b1: ratios[0].b, b2: ratios[1].b, offset: offset };
            }

            function evalHyperbolic(p, x) {
                var w = Math.min(Math.max(0, (p.c - x) / p.t), 1);
                var left = (p.a / p.b1) * Math.sqrt(Math.pow(x - p.c, 2) + Math.pow(p.b1, 2));
                var right = (p.a / p.b2) * Math.sqrt(Math.pow(x - p.c, 2) + Math.pow(p.b2, 2));
                return w * left + (1 - w) * right + p.offset;
            }

            var hyp = parseHyperbolic(fittingsData.Hyperbolic || '');
            if (hyp) {
                for (var x = minPos - pad; x <= maxPos + pad; x += range / 200) {
                    curvePoints.push({ x: x, y: evalHyperbolic(hyp, x) });
                }
            }

            if (curvePoints.length > 0) {
                datasets.push({
                    label: 'Hyperbolic',
                    data: curvePoints,
                    borderColor: 'rgba(255, 159, 64, 0.8)',
                    borderWidth: 2,
                    pointRadius: 0,
                    showLine: true,
                    fill: false,
                    order: 2
                });
            }
        }

        // Calculated focus point
        if (calcPos !== null && calcHfr !== null) {
            datasets.push({
                label: 'Focus',
                data: [{ x: calcPos, y: calcHfr }],
                backgroundColor: 'rgba(75, 192, 75, 1)',
                borderColor: '#fff',
                borderWidth: 2,
                pointRadius: 8,
                pointStyle: 'star',
                showLine: false,
                order: 0
            });
        }

        var annotations = {};
        if (calcPos !== null) {
            annotations.focusLine = {
                type: 'line',
                xMin: calcPos,
                xMax: calcPos,
                borderColor: 'rgba(75, 192, 75, 0.6)',
                borderWidth: 2,
                borderDash: [5, 5],
                label: {
                    display: true,
                    content: 'Focus: ' + Math.round(calcPos),
                    position: 'start',
                    backgroundColor: 'rgba(75, 192, 75, 0.8)',
                    color: '#fff',
                    font: { size: 11 }
                }
            };
        }

        new Chart(ctx, {
            type: 'scatter',
            data: { datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: '{{ 'autofocus.col_position'|trans }}' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: {
                        title: { display: true, text: '{{ 'autofocus.col_hfr'|trans }}' },
                        beginAtZero: false,
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    }
                },
                plugins: {
                    annotation: { annotations: annotations },
                    zoom: {
                        zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' },
                        pan: { enabled: true, mode: 'xy' }
                    },
                    legend: { display: true, position: 'top', labels: { boxWidth: 12 } }
                }
            }
        });
    }

    // Annotated images
    var imagesUrl = '{{ path('api_autofocus_images', {'id': af.id}) }}';
    var imageBaseUrl = '{{ path('api_autofocus_image') }}';
    var grid = document.getElementById('af-images-grid');

    fetch(imagesUrl)
        .then(function(r) { return r.json(); })
        .then(function(images) {
            if (!images || images.length === 0) {
                grid.innerHTML = '<p class="text-muted small">{{ 'autofocus.section_images'|trans }}: —</p>';
                return;
            }
            images.forEach(function(img) {
                var col = document.createElement('div');
                col.className = 'col-4 col-md-3';
                var a = document.createElement('a');
                a.href = '#';
                a.setAttribute('data-bs-toggle', 'modal');
                a.setAttribute('data-bs-target', '#afLightboxModal');
                a.onclick = function() {
                    document.getElementById('afLightboxImg').src = imageBaseUrl + '?path=' + encodeURIComponent(img.path);
                };
                var imgEl = document.createElement('img');
                imgEl.src = imageBaseUrl + '?path=' + encodeURIComponent(img.path);
                imgEl.className = 'img-fluid rounded border';
                imgEl.alt = img.name;
                imgEl.loading = 'lazy';
                a.appendChild(imgEl);
                col.appendChild(a);
                grid.appendChild(col);
            });
        });
})();
</script>
