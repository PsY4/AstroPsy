
<div class="col-md-9 order-xxl-3 lights-viewer">
    {# === Weather Timeline Card ====================================== #}
    <div class="card mt-3">
        <div class="card-header d-flex justify-content-between align-items-center py-2">
            <h5 class="mb-0">{{ 'session.weather_title'|trans }}</h5>
            <select id="weatherDaySelector" class="d-none form-select form-select-sm w-auto"></select>
        </div>
        <div class="card-body">
            <canvas id="weatherChart" height="320"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function(event) {
            (() => {
                // 1) Collect and parse weather samples from LIGHT headers
                const rawSamples = [
                    {% for e in lights %}
                    {{ e.rawHeader|json_encode|raw }},
                    {% endfor %}
                ];

                // normalize one header object into a compact weather point
                const toPoint = (h) => {
                    if (!h) return null;
                    const t = h['DATE-OBS'] || h['DATE-LOC'] || h['DATE-AVG'];
                    if (!t) return null;
                    return {
                        t,
                        cloud: (h.CLOUDCVR ?? null),            // %
                        dew: (h.DEWPOINT ?? null),              // °C
                        hum: (h.HUMIDITY ?? null),              // %
                        press: (h.PRESSURE ?? null),            // hPa (NINA reports mbar ~ hPa)
                        amb: (h.AMBTEMP ?? null),               // °C
                        wdir: (h.WINDDIR ?? null),              // °
                        wgust: (h.WINDGUST ?? null),            // m/s
                        wspd: (h.WINDSPD ?? null),               // m/s
                        airmass: (h.AIRMASS ?? null),               //
                    };
                };

                const weather = rawSamples.map(h => {
                    try {
                        return toPoint(typeof h === 'string' ? JSON.parse(h) : h);
                    } catch {
                        return null;
                    }
                })
                    .filter(Boolean)
                    .sort((a, b) => new Date(a.t) - new Date(b.t));

                if (!weather.length) return;

                const toEpochMs = (s) => {
                    if (!s) return null;
                    // keep only 3 fractional digits if any
                    const msSafe = s.replace(/(\.\d{3})\d+/, '$1');
                    return new Date(msSafe).getTime();
                };

                // Extract date part (YYYY-MM-DD) from an ISO string
                const dayOf = (isoStr) => isoStr.substring(0, 10);

                // 2) Build per-metric time series (Chart.js expects {x, y})
                const asXY = (key, src) => (src || weather)
                    .filter(p => p[key] !== null && p[key] !== undefined)
                    .map(p => ({ x: toEpochMs(p.t), y: p[key] }));

                // Build one point per exposure (bubbles), optionally filtered to a day (YYYY-MM-DD)
                const buildExpPoints = (day) => {
                    const localMap = {};
                    let localNextY = 0.2;
                    const pts = rawSamples.map(h => {
                        let H;
                        try { H = (typeof h === 'string') ? JSON.parse(h) : h; } catch { return null; }
                        const t = H['DATE-OBS'] || H['DATE-LOC'] || H['DATE-AVG'];
                        if (!t) return null;
                        if (day && dayOf(t) !== day) return null;
                        return {
                            x: toEpochMs(t),
                            y: 1,                            // all bubbles sit on the hidden overlay axis
                            _exp: H.EXPOSURE ?? H.EXPTIME,   // stash details for tooltip
                            _filter: H.FILTER ?? null,
                            _airmass: H.AIRMASS ?? null
                        };
                    }).filter(Boolean);
                    pts.forEach(p => {
                        const f = (p._filter || 'Unknown').toUpperCase();
                        if (!(f in localMap)) {
                            localMap[f] = localNextY;
                            localNextY += 0.2;
                        }
                        p.y = localMap[f];
                    });
                    return pts;
                };

                // Initial datasets (all days)
                const allExpPoints = buildExpPoints(null);

                // Multi-day detection
                const days = [...new Set(weather.map(p => dayOf(p.t)))].sort();
                const isMultiDay = days.length > 1;

                // 3) Create chart
                const ctx = document.getElementById('weatherChart').getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            // Temperatures
                            {
                                label: '{{ "session.weather_ambient"|trans }}',
                                data: asXY('amb'),
                                yAxisID: 'yTemp',
                                tension: 0.2,
                                borderWidth: 2.5,
                                pointRadius: 0,
                                borderColor: '#256f77',
                                fill: false,
                            },
                            {
                                label: '{{ "session.weather_dewpoint"|trans }}',
                                data: asXY('dew'),
                                yAxisID: 'yTemp',
                                borderDash: [4, 3],
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#9a0303',
                            },

                            // Humidity / Clouds
                            {
                                label: '{{ "session.weather_humidity"|trans }}',
                                data: asXY('hum'),
                                yAxisID: 'yPct',
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#5693e8',
                            },
                            {
                                label: '{{ "session.weather_cloud"|trans }}',
                                data: asXY('cloud'),
                                yAxisID: 'yPct',
                                borderDash: [2, 2],
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#1973ea',
                            },

                            // Pressure
                            {
                                label: '{{ "session.weather_pressure"|trans }}',
                                data: asXY('press'),
                                yAxisID: 'yPress',
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#b5b5b5',
                            },

                            // Wind
                            {
                                label: '{{ "session.weather_wind"|trans }}',
                                data: asXY('wspd'),
                                yAxisID: 'yWind',
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#ffd879',
                            },
                            {
                                label: '{{ "session.weather_gust"|trans }}',
                                data: asXY('wgust'),
                                yAxisID: 'yWind',
                                borderDash: [6, 3],
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#eaa819',
                            },
                            {
                                label: '{{ "session.weather_airmass"|trans }}',
                                data: asXY('airmass'),
                                yAxisID: 'yAirmass',
                                tension: 0.2,
                                pointRadius: 0,
                                borderColor: '#ffffff',
                            },
                            {
                                label: '{{ "session.weather_light_frames"|trans }}',
                                type: 'scatter',
                                data: allExpPoints,
                                yAxisID: 'yMarks',
                                showLine: false,
                                pointRadius: 4,
                                pointHoverRadius: 7,
                                pointBackgroundColor: '#ffffff',
                                pointBorderColor: '#4f46e5',
                                pointBorderWidth: 2,
                                hitRadius: 10,
                                order: 0,       // draw on top
                                grid: { drawOnChartArea: false },
                                clip: false
                            }

                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {mode: 'nearest', intersect: false},
                        parsing: false,
                        scales: {
                            x: {
                                type: 'time',
                                min: toEpochMs(weather[0].t),
                                max: toEpochMs(weather[weather.length - 1].t),
                                time: {
                                    tooltipFormat: "yyyy-MM-dd HH:mm:ss",
                                    displayFormats: {minute: 'HH:mm', hour: 'HH:mm'}
                                },
                                title: {display: false}
                            },
                            yTemp: {
                                position: 'left',
                                display: false,
                                title: {display: true, text: '°C'},
                                grid: {drawOnChartArea: true}
                            },
                            yPct: {
                                position: 'right',
                                title: {display: true, text: '% (Humidity / Clouds)'},
                                min: 0, max: 100,
                                display: false,
                                grid: {drawOnChartArea: false}
                            },
                            yPress: {
                                position: 'left',
                                title: {display: true, text: 'hPa'},
                                grid: {drawOnChartArea: false},
                                display: false,
                                offset: true
                            },
                            yWind: {
                                position: 'right',
                                display: false,
                                title: {display: true, text: 'm/s (Wind/Gust)'},
                                grid: {drawOnChartArea: false},
                                offset: true
                            },
                            yAirmass: {
                                position: 'right',
                                display: false,
                                title: {display: true, text: ''},
                                grid: {drawOnChartArea: false},
                                offset: true
                            },
                            // Hidden overlay axis for bubble markers
                            yMarks: {
                                position: 'right',
                                display: false,
                                min: 0,
                                max: 1,
                                grid: { drawOnChartArea: false }
                            }
                        },
                        plugins: {
                            legend: { display: true },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        const key = ctx.dataset.label || '';
                                        const v = ctx.parsed.y;

                                        // Bubble tooltip
                                        if (key === '{{ "session.weather_light_frames"|trans }}') {
                                            const d = ctx.raw;
                                            const tt = new Date(ctx.parsed.x).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
                                            const parts = [
                                                `Light @ ${tt}`,
                                                d._exp ? `${d._exp}s` : null,
                                                d._filter ? `Filter: ${d._filter}` : null,
                                                d._airmass ? `Airmass: ${d._airmass.toFixed(2)}` : null
                                            ].filter(Boolean);
                                            return parts.join(' • ');
                                        }

                                        // Your existing formatting
                                        const name = key;
                                        if (name.includes('Pressure') || name.includes('Pression')) return `${name}: ${v.toFixed(1)} hPa`;
                                        if (name.includes('Wind') || name.includes('Gust') || name.includes('Vent') || name.includes('Rafales')) return `${name}: ${v.toFixed(2)} m/s`;
                                        if (name.includes('%')) return `${name}: ${v.toFixed(0)} %`;
                                        return `${name}: ${v.toFixed(2)} °C`;
                                    }
                                }
                            }
                        },

                        elements: {line: {borderWidth: 2}}
                    }
                });

                // 4) Multi-day selector
                if (isMultiDay) {
                    const selector = document.getElementById('weatherDaySelector');
                    selector.classList.remove('d-none');

                    // "All days" option
                    const allOpt = document.createElement('option');
                    allOpt.value = '';
                    allOpt.textContent = '{{ "session.weather_all_days"|trans }}';
                    selector.appendChild(allOpt);

                    // One option per distinct day
                    days.forEach(day => {
                        const opt = document.createElement('option');
                        opt.value = day;
                        opt.textContent = day;
                        selector.appendChild(opt);
                    });

                    // Filter function: updates all datasets and x-axis range
                    const applyDay = (day) => {
                        const w = day ? weather.filter(p => dayOf(p.t) === day) : weather;
                        const ep = buildExpPoints(day || null);

                        chart.data.datasets[0].data = asXY('amb', w);
                        chart.data.datasets[1].data = asXY('dew', w);
                        chart.data.datasets[2].data = asXY('hum', w);
                        chart.data.datasets[3].data = asXY('cloud', w);
                        chart.data.datasets[4].data = asXY('press', w);
                        chart.data.datasets[5].data = asXY('wspd', w);
                        chart.data.datasets[6].data = asXY('wgust', w);
                        chart.data.datasets[7].data = asXY('airmass', w);
                        chart.data.datasets[8].data = ep;

                        if (w.length) {
                            chart.options.scales.x.min = toEpochMs(w[0].t);
                            chart.options.scales.x.max = toEpochMs(w[w.length - 1].t);
                        }
                        chart.update();
                    };

                    selector.addEventListener('change', () => applyDay(selector.value));
                }

            })();
        });
    </script>

</div>


